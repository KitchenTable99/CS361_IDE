/*
 * Authors: Haoyu Song and Dale Skrien
 * Latest change: Oct. 5, 2021
 *
 * In the grammar below, the variables are enclosed in angle brackets and
 * "::=" is used instead of "-->" to separate a variable from its rules.
 * The special character "|" is used to separate the rules for each variable
 * (but note that "||" is an operator).
 * EMPTY indicates a rule with an empty right-hand side.
 * All other symbols in the rules are terminals.
 */
package proj7BittingCerratoCohenEllmer.bantam.parser;

import proj7BittingCerratoCohenEllmer.bantam.ast.*;
import proj7BittingCerratoCohenEllmer.bantam.lexer.Scanner;
import proj7BittingCerratoCohenEllmer.bantam.lexer.Token;
import proj7BittingCerratoCohenEllmer.bantam.util.CompilationException;
import proj7BittingCerratoCohenEllmer.bantam.util.Error;
import proj7BittingCerratoCohenEllmer.bantam.util.ErrorHandler;

public class Parser {
    // instance variables
    private Scanner scanner; // provides the tokens
    private Token currentToken; // the lookahead token
    private ErrorHandler errorHandler; // collects & organizes the error messages

    // constructor
    public Parser(ErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
    }

    /**
     * parse the given file and return the root node of the AST
     *
     * @param filename The name of the Bantam Java file to be parsed
     * @return The Program node forming the root of the AST generated by the parser
     */
    public Program parse(String filename) {
        // initialize scanner for each file
        errorHandler = new ErrorHandler();
        scanner = new Scanner(filename, errorHandler);
        currentToken = scanner.scan(true);
        return parseProgram();
    }


    // <Program> ::= <Class> | <Class> <Program>
    private Program parseProgram() {
        int position = currentToken.position;
        ClassList clist = new ClassList(position);

        while (currentToken.kind != Token.Kind.EOF) {
            Class_ aClass = parseClass();
            clist.addElement(aClass);
        }

        return new Program(position, clist);
    }


    // <Class> ::= CLASS <Identifier> <ExtendsClause> { <MemberList> }
    // <ExtendsClause> ::= EXTENDS <Identifier> | EMPTY
    // <MemberList> ::= EMPTY | <Member> <MemberList>
    private Class_ parseClass() {
        int position = currentToken.position;
        MemberList memberList = new MemberList(position);

        // get class name
        currentToken = scanner.scan(true);
        ensureTokenType("Class name is not valid", Token.Kind.IDENTIFIER);
        String name = currentToken.spelling;

        // handle extends
        currentToken = scanner.scan(true);
        String parent;
        if (currentToken.kind == Token.Kind.EXTENDS) {
            currentToken = scanner.scan(true);
            parent = parseIdentifier();
        } else {
            parent = null;
        }

        // enter class body
        ensureTokenType("Class definition must begin with '{'", Token.Kind.LCURLY);
        currentToken = scanner.scan(true);

        // parse all members. when EMPTY token will be '}'
        while (currentToken.kind != Token.Kind.RCURLY) {
            // if we reach end of file, we have an error
            if (currentToken.kind == Token.Kind.EOF) {
                registerAndThrow("Incomplete Class Declaration:" +
                        " EOF occurred before closing '}'");
            }
            memberList.addElement(parseMember());
        }

        // ensure invariants
        currentToken = scanner.scan(true);
        return new Class_(position, scanner.getFilename(), name, parent, memberList);
    }


    //Fields and Methods
    // <Member> ::= <Field> | <Method>
    // <Method> ::= <Type> <Identifier> ( <Parameters> ) <BlockStmt>
    // <Field> ::= <Type> <Identifier> <InitialValue> ;
    // <InitialValue> ::= EMPTY | = <Expression>
    private Member parseMember() {
        // both fields and methods share position, type, and identifier
        int position = currentToken.position;
        String type = parseType();
        String identifier = parseIdentifier();

        // method
        if (currentToken.kind == Token.Kind.LPAREN) {
            // get parameters
            currentToken = scanner.scan();
            FormalList params = parseParameters();
            ensureTokenType("Invalid Method Declaration:" +
                    " Must close parameter list with ')'");

            // get method mody
            currentToken = scanner.scan();
            Stmt blockStmt = parseBlock();
            StmtList stmtList = ((BlockStmt) blockStmt).getStmtList();
            return new Method(position, type, identifier, params, stmtList);

            // field
        } else {
            // get the <InitialValue>
            Expr expr;
            if (currentToken.kind == Token.Kind.ASSIGN) {
                currentToken = scanner.scan(true);
                expr = parseExpression();
            } else {
                expr = null;
            }

            // ensure semicolon and set the invariant
            ensureTokenType("Invalid Field Declaration:" +
                    " Must end a field with a semicolon", Token.Kind.SEMICOLON);
            currentToken = scanner.scan(true);
            return new Field(position, type, identifier, expr);
        }
    }


    //-----------------------------------
    //Statements
    // <Stmt> ::= <WhileStmt> | <ReturnStmt> | <BreakStmt> | <VarDeclaration>
    //             | <ExpressionStmt> | <ForStmt> | <BlockStmt> | <IfStmt>
    private Stmt parseStatement() {
        switch (currentToken.kind) {
            case IF:
                return parseIf();
            case LCURLY:
                return parseBlock();
            case VAR:
                return parseVarDeclaration();
            case RETURN:
                return parseReturn();
            case FOR:
                return parseFor();
            case WHILE:
                return parseWhile();
            case BREAK:
                return parseBreak();
            default:
                return parseExpressionStmt();
        }
    }


    // <WhileStmt> ::= WHILE ( <Expression> ) <Stmt>
    private Stmt parseWhile() {
        int position = currentToken.position;

        // enter while body
        currentToken = scanner.scan(true);
        ensureTokenType("Incomplete Statement: While statement missing an opening '('",
                Token.Kind.LPAREN);

        // parse predicate body
        currentToken = scanner.scan(true);
        Expr predStmt = parseExpression();

        // ensure predicate finished
        ensureTokenType("Incomplete Statement: While statement missing a closing ')'",
                Token.Kind.RPAREN);

        // parse loop body
        currentToken = scanner.scan(true);
        Stmt bodyStmt = parseStatement();

        return new WhileStmt(position, predStmt, bodyStmt);
    }


    // <ReturnStmt> ::= RETURN <Expression> ; | RETURN ;
    private Stmt parseReturn() {
        int position = currentToken.position;

        // determine if empty return or return expression
        Expr returnExpression;
        currentToken = scanner.scan(true);
        if (currentToken.kind != Token.Kind.SEMICOLON) {
            returnExpression = parseExpression();
        } else {
            returnExpression = null;
        }

        // ensure semicolon ending
        ensureTokenType("Invalid Return Statement: Missing an ending ';'",
                Token.Kind.SEMICOLON);

        currentToken = scanner.scan(true);
        return new ReturnStmt(position, returnExpression);
    }


    // <BreakStmt> ::= BREAK ;
    private Stmt parseBreak() {
        int position = currentToken.position;

        // ensure semicolon ending
        ensureTokenType("Invalid Break Statement: Break statement must end with ';'",
                Token.Kind.SEMICOLON);

        currentToken = scanner.scan(true);
        return new BreakStmt(position);
    }


    // <ExpressionStmt> ::= <Expression> ;
    private ExprStmt parseExpressionStmt() {
        int position = currentToken.position;

        // parse the expression
        Expr expression = parseExpression();

        // ensure semicolon ending
        ensureTokenType("Invalid Expression: Expression statement must end with ';'",
                Token.Kind.SEMICOLON);
        return new ExprStmt(position, expression);
    }


    // <VarDeclaration> ::= VAR <Id> = <Expression> ;
    // Every local variable must be initialized
    private Stmt parseVarDeclaration() {
        int position = currentToken.position;

        // get var name
        currentToken = scanner.scan(true);
        ensureTokenType("Invalid Variable Name", Token.Kind.IDENTIFIER);
        String varID = currentToken.spelling;

        // ensure assignment
        currentToken = scanner.scan(true);
        ensureTokenType("Invalid Declaration Statement:" +
                " All variables must be initialized", Token.Kind.ASSIGN);

        // get assignment expression
        currentToken = scanner.scan(true);
        Expr expr = parseExpression();

        // ensure semicolon ending
        ensureTokenType("Invalid Declaration Statement: Missing ending ';'",
                Token.Kind.SEMICOLON);

        // ensure invariant
        currentToken = scanner.scan(true);

        return new DeclStmt(position, varID, expr);
    }


    // <ForStmt> ::= FOR ( <Start> ; <Terminate> ; <Increment> ) <STMT>
    // <Start> ::=     EMPTY | <Expression>
    // <Terminate> ::= EMPTY | <Expression>
    // <Increment> ::= EMPTY | <Expression>
    private Stmt parseFor() {
        int position = currentToken.position;

        // ensure predicate stuff contained in parentheses
        currentToken = scanner.scan(true);
        ensureTokenType("Invalid For Loop: Predicates must begin with '('",
                Token.Kind.LPAREN);

        // start expr
        currentToken = scanner.scan(true);
        Expr initExpr;
        if (currentToken.kind != Token.Kind.SEMICOLON) {
            initExpr = parseExpression();
        } else {
            initExpr = null;
        }
        ensureTokenType("Invalid For Loop: You must delimit predicates with a ';'",
                Token.Kind.SEMICOLON);

        // terminating expr
        currentToken = scanner.scan(true);
        Expr termExpr;
        if (currentToken.kind != Token.Kind.SEMICOLON) {
            termExpr = parseExpression();
        } else {
            termExpr = null;
        }
        ensureTokenType("Invalid For Loop: You must delimit predicates with a ';'",
                Token.Kind.SEMICOLON);

        // increment expression
        currentToken = scanner.scan(true);
        Expr updateExpr;
        if (currentToken.kind != Token.Kind.RPAREN) {
            updateExpr = parseExpression();
        } else {
            updateExpr = null;
        }

        // ensure predicate closed
        ensureTokenType("Invalid For Loop: You must close the predicates with a ')'",
                Token.Kind.RPAREN);

        // get body statement
        currentToken = scanner.scan(true);
        Stmt bodyStmt = parseStatement();

        return new ForStmt(position, initExpr, termExpr, updateExpr, bodyStmt);
    }


    // <BlockStmt> ::= { <Body> }
    // <Body> ::= EMPTY | <Stmt> <Body>
    private Stmt parseBlock() {
        int position = currentToken.position;

        // open the block statement
        ensureTokenType("Invalid Block Statement: missing '{'", Token.Kind.LCURLY);

        // create statement list
        StmtList stmtList = new StmtList(position);
        currentToken = scanner.scan(true); // either a Body or a '}'
        while (currentToken.kind != Token.Kind.RCURLY) {
            // if we reach end of file, we have an error
            if (currentToken.kind == Token.Kind.EOF) {
                errorHandler.register(Error.Kind.PARSE_ERROR, "Invalid Block Statement");
                throw new CompilationException(
                        "Incomplete Statement: Block statement missing a '}'",
                        new Throwable());
            }

            stmtList.addElement(parseStatement()); // add the statement
        }

        // we know that we're looking at a '}' token, so just advance
        currentToken = scanner.scan(true);

        return new BlockStmt(position, stmtList);
    }


    // <IfStmt> ::= IF ( <Expr> ) <Stmt> | IF ( <Expr> ) <Stmt> ELSE <Stmt>
    private Stmt parseIf() {
        int position = currentToken.position;

        // ensure predicate opens with '('
        currentToken = scanner.scan(true); // (
        ensureTokenType("Invalid If Statement: missing opening '('", Token.Kind.LPAREN);

        // get predicate
        currentToken = scanner.scan(true); // expr
        Expr predExpr = parseExpression();

        // ensure closed with '('
        ensureTokenType("Invalid If Statement: missing closing ')'", Token.Kind.RPAREN);

        // get the body of if statement
        currentToken = scanner.scan();
        Stmt thenStmt = parseStatement();

        // get the body of the else statement if one is present
        Stmt elseStmt;
        if (currentToken.kind == Token.Kind.ELSE) {
            currentToken = scanner.scan();
            elseStmt = parseStatement();
        } else {
            elseStmt = null;
        }

        // invariant already satisfied
        return new IfStmt(position, predExpr, thenStmt, elseStmt);
    }


    //-----------------------------------------
    // Expressions
    // Here we use different rules than the grammar on page 49
    // of the manual to handle the precedence of operations

    // <Expression> ::= <LogicalORExpr> <OptionalAssignment>
    // <OptionalAssignment> ::= EMPTY | = <Expression>
    private Expr parseExpression() {
        int position = currentToken.position;

        // get the leftside stuff
        String leftName = currentToken.getSpelling();
        Expr left = parseOrExpr();

        // check to see if there's an assignment
        String refName = currentToken.getSpelling(); // literally no idea what this is or if it's useful
        if (currentToken.kind == Token.Kind.ASSIGN) {
            currentToken = scanner.scan(true);
            Expr right = parseExpression();
            left = new AssignExpr(position, refName, leftName, right);
        }
        return left;
    }


    // <LogicalOR> ::= <logicalAND> <LogicalORRest>
    // <LogicalORRest> ::= EMPTY |  || <LogicalAND> <LogicalORRest>
    private Expr parseOrExpr() {
        int position = currentToken.position;
        Expr left;

        left = parseAndExpr();
        while (currentToken.spelling.equals("||")) {
            //...advance to the next token...
            Expr right = parseAndExpr();
            left = new BinaryLogicOrExpr(position, left, right);
        }

        return left;
    }


    // <LogicalAND> ::= <ComparisonExpr> <LogicalANDRest>
    // <LogicalANDRest> ::= EMPTY |  && <ComparisonExpr> <LogicalANDRest>
    private Expr parseAndExpr() {
        int position = currentToken.position;

        Expr left = parseComparisonExpr();
        while (currentToken.spelling.equals("&&")) {
            Expr right = parseComparisonExpr();
            left = new BinaryLogicAndExpr(position, left, right);
        }
        return left;
    }


    // <ComparisonExpr> ::= <RelationalExpr> <equalOrNotEqual> <RelationalExpr> |
    //                      <RelationalExpr>
    // <equalOrNotEqual> ::=  == | !=
    private Expr parseComparisonExpr() {
        int position = currentToken.position;

        // get the left piece
        Expr left = parseRelationalExpr();

        // if the current token is == or != parse the right half
        if (currentToken.kind == Token.Kind.BINARYLOGIC) {
            String typeOfEq = currentToken.spelling;
            currentToken = scanner.scan(); // currentToken: <RelationalExpr>
            Expr right = parseRelationalExpr();
            if (typeOfEq.equals("==")) {
                left = new BinaryCompEqExpr(position, left, right);
            } else {
                left = new BinaryCompNeExpr(position, left, right);
            }

        }
        return left;
    }


    // <RelationalExpr> ::= <AddExpr> | <AddExpr> <ComparisonOp> <AddExpr>
    // <ComparisonOp> ::= < | > | <= | >=
    private Expr parseRelationalExpr() {
        int position = currentToken.position;

        // get the first <AddExpr>
        Expr left = parseAddExpr();

        // check if there is a <ComparisonOp>
        if (currentToken.kind == Token.Kind.COMPARE) {
            String compOp = currentToken.spelling;

            // get right side of equation
            currentToken = scanner.scan(true);
            Expr right = parseAddExpr();

            // return correct expression
            switch (compOp) {
                case "<":
                    return new BinaryCompLtExpr(position, left, right);
                case ">":
                    return new BinaryCompGtExpr(position, left, right);
                case "<=":
                    return new BinaryCompLeqExpr(position, left, right);
                case ">=":
                    return new BinaryCompGeqExpr(position, left, right);
                default:
                    throw new RuntimeException("Somehow a token other than '>', '<'," +
                            " '>=', or '<=' was scanned as a comparison token");
            }
        } else {
            return left;  // this is just the original <AddExpr>
        }
    }

    // <AddExpr>::＝ <MultExpr> <MoreMultExpr>
    // <MoreMultExpr> ::= EMPTY | + <MultExpr> <MoreMultExpr> | - <MultExpr> <MoreMultExpr>
    private Expr parseAddExpr() {
        int position = currentToken.position;

        // get initial <MultExpr>
        Expr left = parseMultExpr();

        if (currentToken.kind == Token.Kind.PLUSMINUS) {
            String operation = currentToken.spelling;

            // get the rest of the <MoreMultExpr>
            currentToken = scanner.scan(true);
            Expr right = parseMultExpr();

            if (operation.equals("+")) {
                return new BinaryArithPlusExpr(position, left, right);
            } else {
                return new BinaryArithMinusExpr(position, left, right);
            }
        } else {
            return left;
        }
    }

    // <MultiExpr> ::= <NewCastOrUnary> <MoreNCU>
    // <MoreNCU> ::= * <NewCastOrUnary> <MoreNCU> |
    //               / <NewCastOrUnary> <MoreNCU> |
    //               % <NewCastOrUnary> <MoreNCU> |
    //               EMPTY
    private Expr parseMultExpr() {
        int position = currentToken.position;

        // get initial <NewCastOrUnary>
        Expr left = parseNewCastOrUnary();

        if (currentToken.kind == Token.Kind.MULDIV) { // this assumes "%" is divmul
            String relationalOp = currentToken.spelling;

            // get rest of <MoreNCU>
            currentToken = scanner.scan(true);
            Expr right = parseNewCastOrUnary();

            if (relationalOp.equals("*")) {
                return new BinaryArithTimesExpr(position, left, right);
            } else if (relationalOp.equals("/")) {
                return new BinaryArithDivideExpr(position, left, right);
            } else {
                return new BinaryArithModulusExpr(position, left, right);
            }
        } else {
            return left;
        }
    }

    // <NewCastOrUnary> ::= <NewExpression> | <CastExpression> | <UnaryPrefix>
    private Expr parseNewCastOrUnary() {
        switch(currentToken.kind){
            case NEW: // NewExpression
                currentToken = scanner.scan(true);
                return parseNew();
            case CAST: // CastExpression
                currentToken = scanner.scan(true);
                return parseCast();
            default: // UnaryPrefix
                return parseUnaryPrefix();
        }
    }


    // <NewExpression> ::= NEW <Identifier> ( )
    private Expr parseNew() {
        int position = currentToken.position;

        currentToken = scanner.scan(true); // currentToken: <Identifier>
        String type = parseIdentifier();

        currentToken = scanner.scan(true); // gets '(' or this is an error
        ensureTokenType("Incomplete Statement: New statement missing a '('",
                Token.Kind.LPAREN);

        currentToken = scanner.scan(true); // gets ')' or this is an error
        ensureTokenType("Incomplete Statement: New statement missing a ')'",
                Token.Kind.RPAREN);

        return new NewExpr(position, type);
    }


    // <CastExpression> ::= CAST ( <Type> , <Expression> )
    private Expr parseCast() {
        int lineNum = currentToken.position;

        currentToken = scanner.scan(true); // gets '(' or this is an error
        ensureTokenType("Incomplete Statement: Cast statement missing a '('",
                Token.Kind.LPAREN);

        currentToken = scanner.scan(true); // gets type
        String type = parseType();

        currentToken = scanner.scan(true); // gets ',' or this is an error
        ensureTokenType("Incomplete Statement: Cast statement missing a ','",
                Token.Kind.COMMA);

        currentToken = scanner.scan(true); // gets expression
        Expr expr = parseExpression();

        currentToken = scanner.scan(true); // gets ')' or this is an error
        ensureTokenType("Incomplete Statement: Cast statement missing a ')'",
                Token.Kind.RPAREN);

        return new CastExpr(lineNum, type, expr);
    }


    // <UnaryPrefix> ::= <PrefixOp> <UnaryPreFix> | <UnaryPostfix>
    // <PrefixOp> ::= - | ! | ++ | --
    private Expr parseUnaryPrefix() {
        int position = currentToken.position;

        switch(currentToken.kind) {
            case PLUSMINUS: // - or +, but here we only care about -
                currentToken = scanner.scan(true); // satisfy invariant
                return new UnaryNegExpr(position, parseUnaryPrefix());
            case UNARYNOT: // !
                currentToken = scanner.scan(true);
                return new UnaryNotExpr(position, parseUnaryPrefix());
            case UNARYINCR: // ++
                currentToken = scanner.scan(true);
                return new UnaryIncrExpr(position, parseUnaryPrefix(), false);
            case UNARYDECR: // --
                currentToken = scanner.scan(true);
                return new UnaryDecrExpr(position, parseUnaryPrefix(), false);
            default:
                return parseUnaryPostfix();
        }
    }


    // <UnaryPostfix> ::= <Primary> <PostfixOp>
    // <PostfixOp> ::= ++ | -- | EMPTY
    private Expr parseUnaryPostfix() {
        int position = currentToken.position;

        Expr primary = parsePrimary(); // gets the primary
        currentToken = scanner.scan(true); // gets the postfix operator

        // returns expression
        switch (currentToken.kind) {
            case UNARYINCR:
                return new UnaryIncrExpr(position, primary, true); // ++
            case UNARYDECR:
                return new UnaryDecrExpr(position, primary, true); // --
            default:
                return primary; // empty, so just the primary
        }
    }


    // <Primary> ::= ( <Expression> ) | <IntegerConst> | <BooleanConst> |
    //                                  <StringConst>  | <VarExpr>
    // <VarExpr> ::= <VarExprPrefix> <Identifier> <VarExprSuffix>
    // <VarExprPrefix> ::= SUPER . | THIS . | EMPTY
    // <VarExprSuffix> ::= ( <Arguments> ) | EMPTY
    private Expr parsePrimary() {
        int position = currentToken.position;
        Expr exprToReturn;

        // handle ( <Expression> )
        if (currentToken.kind == Token.Kind.LPAREN) {
            currentToken = scanner.scan(true); // currentToken: <Expression>
            exprToReturn = parseExpression(); // currentToken: )
            ensureTokenType("Incomplete Expression: Unclosed Parenthesis",
                    Token.Kind.RPAREN);
            currentToken = scanner.scan(true); // prep next token

            // handle integerConst
        } else if (currentToken.kind == Token.Kind.INTCONST) {
            exprToReturn = parseIntConst();

            // handle booleanConst
        } else if (currentToken.kind == Token.Kind.BOOLEAN) {
            exprToReturn = parseBoolean();

            // handle StringConst
        } else if (currentToken.kind == Token.Kind.STRCONST) {
            exprToReturn = parseStringConst();

            // handle VarExpr
        } else {
            // get prefix (super or this)
            Expr refExpr;
            String spelling = currentToken.spelling;
            if ("super".equals(spelling) || "this".equals(spelling)) {
                // todo: TEST THE SHIT OUT OF THIS
                refExpr = parseExpression(); // currentToken: '.'
                ensureTokenType("reference call missing separator '.'", Token.Kind.DOT);

                currentToken = scanner.scan(true); // currentToken: <identifier>
            } else {
                refExpr = null; // currentToken: <identifier>
            }

            // get method name
            String methodName = parseIdentifier(); // currentToken: ( or EMPTY

            // handle ( <Arguments> )
            ExprList args;
            if (currentToken.kind == Token.Kind.LPAREN) {
                currentToken = scanner.scan(true);
                args = parseArguments();
                ensureTokenType("Method Call Incomplete:" +
                        " Unclosed Parenthesis, Missing')", Token.Kind.RPAREN);
                currentToken = scanner.scan(true); // prep next token
            } else {
                args = null;
            }
            exprToReturn = new DispatchExpr(position, refExpr, methodName, args);
        }
        return exprToReturn;
    }


    // <Arguments> ::= EMPTY | <Expression> <MoreArgs>
    // <MoreArgs>  ::= EMPTY | , <Expression> <MoreArgs>
    private ExprList parseArguments() {
        ExprList arguments = new ExprList(currentToken.position); // makes empty ExprList

        while (currentToken.kind != Token.Kind.RPAREN) {
            arguments.addElement(parseExpression()); // add Expression to ExprList

            ensureTokenType("Incomplete Statement:" +
                            " Parameter statement missing a ')' or ','",
                    Token.Kind.COMMA, Token.Kind.RPAREN);

            if (currentToken.kind == Token.Kind.COMMA) { // if it's a ',' we ignore it
                currentToken = scanner.scan(true);
            }
        }

        return arguments;
    }


    // <Parameters> ::=  EMPTY | <Formal> <MoreFormals>
    // <MoreFormals> ::= EMPTY | , <Formal> <MoreFormals
    private FormalList parseParameters() {
        FormalList parameters = new FormalList(currentToken.position); // makes empty FormalList

        while (currentToken.kind != Token.Kind.RPAREN) {
            parameters.addElement(parseFormal()); // Add Formal to FormalList

            ensureTokenType("Incomplete Statement:" +
                            " Parameter statement missing a ')' or ','", Token.Kind.COMMA,
                    Token.Kind.RPAREN);

            if (currentToken.kind == Token.Kind.COMMA) { // if it's a ',' we ignore it and go to the next
                currentToken = scanner.scan(true);      // formal parameter to parse
            }
        }

        return parameters;
    }


    // <Formal> ::= <Type> <Identifier>
    private Formal parseFormal() {
        int position = currentToken.position;

        String type = parseType();
        String name = parseIdentifier();
        return new Formal(position, type, name);
    }


    // <Type> ::= <Identifier>
    private String parseType() {
        return parseIdentifier();
    }


    //----------------------------------------
    //Terminals
    private String parseIdentifier() {
        // ensure the correct type
        ensureTokenType("Invalid identifier token", Token.Kind.IDENTIFIER);

        // get the needed information
        String identifier = currentToken.getSpelling();

        // ensure invariant
        currentToken = scanner.scan(true);
        return identifier;
    }


    private ConstStringExpr parseStringConst() {
        // ensure correct token type
        ensureTokenType("Invalid String Value: Not a string", Token.Kind.STRCONST);

        // extract needed information
        int position = currentToken.position;
        String constant = currentToken.getSpelling();

        // ensure invariant
        currentToken = scanner.scan(true);
        return new ConstStringExpr(position, constant);
    }


    private ConstIntExpr parseIntConst() {
        // ensure correct token type
        ensureTokenType("Invalid Integer Value:" +
                " Expected Integer value in range 0-2147483647", Token.Kind.INTCONST);

        // get needed information
        int position = currentToken.position;
        String constant = currentToken.getSpelling();

        // ensure invariant
        currentToken = scanner.scan(true);
        return new ConstIntExpr(position, constant);
    }


    private ConstBooleanExpr parseBoolean() {
        // ensure correct token type
        ensureTokenType("Invalid Integer Value:" +
                " Expected 'true' or 'false' as a boolean value", Token.Kind.BOOLEAN);

        // get needed information
        int position = currentToken.position;
        String constant = currentToken.getSpelling();

        // ensure invariant
        currentToken = scanner.scan(true);
        return new ConstBooleanExpr(position, constant);
    }

    /**
     * Helper method that checks the current token for the passed types. If it does not
     * match one of the passed types, the method registers an error with the passed
     * message with the internal error handler and raises a compilation exception.
     *
     * @param errorMessage to register and raise if needed
     * @param kinds        one or more Token.Kind values against which to check the type
     *                     of the current token
     */
    private void ensureTokenType(String errorMessage, Token.Kind... kinds) {
        // see if current token is one of the passed types
        boolean currentTokenTypeFound = false;
        for (Token.Kind kind : kinds) {
            if (currentToken.kind == kind) {
                currentTokenTypeFound = true;
                break;
            }
        }

        if (!currentTokenTypeFound) {
            registerAndThrow(errorMessage);
        }
    }

    /**
     * Helper method that registers an error with the internal error handler and throws
     * the exception to stop the parsing.
     *
     * @param errorMessage to display in the error handler and in the runtime exception
     */
    private void registerAndThrow(String errorMessage) {
        errorHandler.register(Error.Kind.PARSE_ERROR, errorMessage);
        throw new CompilationException(errorMessage, new Throwable());
    }

}

